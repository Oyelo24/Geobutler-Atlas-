import 'package:atlas_field_companion/shared/models/models.dart';

import 'survey_computations.dart' show SurveyComputations, ClosureResult;
import 'services.dart' hide SurveyComputations;

class ReportService {
  
  /// Generate comprehensive survey report
  static Future<SurveyReport> generateReport(Project project, List<SurveyPoint> points) async {
    try {
      final computations = SurveyComputations.generateMeasurements(points);
      final warnings = SurveyComputations.detectAnomalies(points);
      final closure = SurveyComputations.calculateClosure(points);
      
      // Get actual surveyor info from backend
      String surveyorName = 'Unknown Surveyor';
      try {
        final profile = await SurveyorService.getMyProfile(1);
        if (profile != null) {
          surveyorName = '${profile.firstName} ${profile.lastName}'.trim();
        }
      } catch (e) {
        // Use fallback if backend unavailable
      }
      
      return SurveyReport(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        projectId: project.id,
        projectName: project.name,
        location: project.location,
        surveyType: project.surveyType,
        coordinateSystem: project.coordinateSystem,
        surveyorName: surveyorName,
        reportDate: DateTime.now(),
        summary: _generateSummary(project, points, closure),
        points: points,
        measurements: computations,
        warnings: warnings,
        closure: closure,
        recommendations: _generateRecommendations(warnings, closure),
      );
    } catch (e) {
      throw 'Failed to generate report: $e';
    }
  }
  
  /// Generate PDF report content
  static String generatePDFContent(SurveyReport report) {
    return '''
# SURVEY REPORT

## Project Information
**Project:** ${report.projectName}
**Location:** ${report.location}
**Survey Type:** ${report.surveyType.name.toUpperCase()}
**Coordinate System:** ${report.coordinateSystem}
**Surveyor:** ${report.surveyorName}
**Date:** ${report.reportDate.toString().split(' ')[0]}

## Summary
${report.summary}

## Points Collected (${report.points.length})
${report.points.map((p) => '${p.pointId}: ${p.latitude.toStringAsFixed(6)}, ${p.longitude.toStringAsFixed(6)} (±${p.accuracy.toStringAsFixed(2)}m)').join('\n')}

## Measurements
${report.measurements.map((m) => '${m.fromPointId} → ${m.toPointId}: ${m.value.toStringAsFixed(3)} ${m.unit} (${m.type.name})').join('\n')}

## Quality Assessment
**Linear Closure Error:** ${report.closure.linearError.toStringAsFixed(3)}m
**Precision:** 1:${(1 / report.closure.precision).toStringAsFixed(0)}
**Status:** ${report.closure.isAcceptable ? 'ACCEPTABLE' : 'REQUIRES ATTENTION'}

## Warnings (${report.warnings.length})
${report.warnings.map((w) => '⚠️ ${w.message}').join('\n')}

## Recommendations
${report.recommendations.join('\n• ')}

---
Generated by GeoButler v1.0.0
''';
  }
  
  /// Generate Excel/CSV content
  static String generateCSVContent(SurveyReport report) {
    String csv = 'Point ID,Latitude,Longitude,Elevation,Accuracy,Description,Timestamp\n';
    
    for (var point in report.points) {
      csv += '${point.pointId},${point.latitude},${point.longitude},${point.elevation},${point.accuracy},"${point.description}",${point.timestamp}\n';
    }
    
    return csv;
  }
  
  /// Generate coordinate schedule
  static String generateCoordinateSchedule(SurveyReport report) {
    String schedule = 'COORDINATE SCHEDULE\n\n';
    schedule += 'Project: ${report.projectName}\n';
    schedule += 'Coordinate System: ${report.coordinateSystem}\n\n';
    schedule += 'Point ID\tEasting\tNorthing\tElevation\tAccuracy\n';
    
    for (var point in report.points) {
      schedule += '${point.pointId}\t${point.longitude.toStringAsFixed(6)}\t${point.latitude.toStringAsFixed(6)}\t${point.elevation.toStringAsFixed(3)}\t±${point.accuracy.toStringAsFixed(2)}m\n';
    }
    
    return schedule;
  }
  
  static String _generateSummary(Project project, List<SurveyPoint> points, ClosureResult closure) {
    return '''
Survey completed with ${points.length} points collected. 
Overall data quality is ${_getQualityRating(points)}. 
Closure precision: 1:${(1 / closure.precision).toStringAsFixed(0)}.
${closure.message}''';
  }
  
  static String _getQualityRating(List<SurveyPoint> points) {
    if (points.isEmpty) return 'NO DATA';
    double avgAccuracy = points.map((p) => p.accuracy).reduce((a, b) => a + b) / points.length;
    if (avgAccuracy <= 3.0) return 'EXCELLENT';
    if (avgAccuracy <= 5.0) return 'GOOD';
    if (avgAccuracy <= 8.0) return 'FAIR';
    return 'POOR';
  }
  
  static List<String> _generateRecommendations(List<DataWarning> warnings, ClosureResult closure) {
    List<String> recommendations = [];
    
    if (!closure.isAcceptable) {
      recommendations.add('Review traverse measurements and re-observe critical angles');
    }
    
    if (warnings.any((w) => w.type == WarningType.poorAccuracy)) {
      recommendations.add('Re-observe points with poor GPS accuracy');
    }
    
    if (warnings.any((w) => w.type == WarningType.duplicate)) {
      recommendations.add('Remove or consolidate duplicate point observations');
    }
    
    if (recommendations.isEmpty) {
      recommendations.add('Survey meets quality standards - proceed with deliverables');
    }
    
    return recommendations;
  }
}

class SurveyReport {
  final String id;
  final String projectId;
  final String projectName;
  final String location;
  final SurveyType surveyType;
  final String coordinateSystem;
  final String surveyorName;
  final DateTime reportDate;
  final String summary;
  final List<SurveyPoint> points;
  final List<Measurement> measurements;
  final List<DataWarning> warnings;
  final ClosureResult closure;
  final List<String> recommendations;
  
  const SurveyReport({
    required this.id,
    required this.projectId,
    required this.projectName,
    required this.location,
    required this.surveyType,
    required this.coordinateSystem,
    required this.surveyorName,
    required this.reportDate,
    required this.summary,
    required this.points,
    required this.measurements,
    required this.warnings,
    required this.closure,
    required this.recommendations,
  });
}